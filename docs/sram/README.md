# SRAM

## スロット

セーブデータ本体です。

```
  0xE00_0000 + (2730 * 0): ストーリーデータ1
  0xE00_0000 + (2730 * 1): ストーリーデータ2
  0xE00_0000 + (2730 * 2): ストーリーデータ3
  0xE00_0000 + (2730 * 3): ストーリーデータ4
  0xE00_0000 + (2730 * 4): ストーリーデータ5
  0xE00_0000 + (2730 * 5): システムデータ
```

### スロットのバックアップ

各スロットはバックアップを持っていて、メインのデータが壊れている場合にこちらを使用します。

```
  0xE00_3FFC + (2730 * 0): ストーリーデータ1 (のバックアップ)
  0xE00_3FFC + (2730 * 1): ストーリーデータ2 (のバックアップ)
  0xE00_3FFC + (2730 * 2): ストーリーデータ3 (のバックアップ)
  0xE00_3FFC + (2730 * 3): ストーリーデータ4 (のバックアップ)
  0xE00_3FFC + (2730 * 4): ストーリーデータ5 (のバックアップ)
  0xE00_3FFC + (2730 * 5): システムデータ  (のバックアップ)
```

## 起動時(リセット時)

ゲームが起動した時に、セーブデータを読み込む処理は `initGameSavedata`関数(`0x080ebb3c`) で行われます。

起動時は、どのストーリーデータも選択されていないので、システムのセーブデータ(システムデータ)を読み込みます。

システムデータを読み込んだら、次にストーリーデータ(1~5)が壊れていないか全てチェックします。

1つでも壊れていないストーリーデータがあったら、`02030910` を 1 にします。(おそらく "つづきから" を表示するかのフラグ)

### 破損チェック

`checkSavedataCorrect`関数(`08003228`) で行います。

```c
// saveIdx: 1~5
// length: セーブデータのサイズ(592バイト)
bool8 checkSavedataCorrect(u32 saveIdx, s32 length);
```

ストーリーデータの先頭16バイトを読み込んで、

```
  マジックナンバーのチェック(0..4バイトが INTI か)
  バイトサイズのチェック(8..11バイトが 引数のlength と等しいか)
  12バイトが 0x0B か
  ストーリーデータの番号チェック(15バイトが 引数のsaveIdx と等しいか)
```

をチェックします。

読み込み失敗を考えて、失敗時は合計3回までリトライします。

## 読み込み

`loadSram`関数(`08003534`) で行います。

複数フレームにわたって、`loadSram`関数を呼び出してセーブデータの読み込みをします。

```
// health は 0x02001efe

BusStatus(0x02001ee3):
  0: ヘッダを読み取って問題がないなら 1 にして終了
  1: バッチをロード 最後のバッチをロードしたら 2 にして終了
  2: チェックサムの確認
    OK: health を OK(0x01) にして終了
    NG:
      health を BROKEN(0xFFFF)にして、useBackupの値で分岐
      useBackup(0x02001ee6)
        0: useBackupを1にしてもう一回
        1: 終了(最後に読み込んだセーブデータが壊れていようが壊れていまいが)
```

チェックサムの確認は3回までリトライします。

3回リトライしてもダメだった場合は、バックアップデータで再挑戦します。

それでもダメなら最後に読み取ったセーブデータ、つまり3回目のバックアップデータでゲームを再開します。

